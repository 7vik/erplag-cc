<program> -> <moduleDeclarations> <otherModules> <driverModule> <otherModules>
<moduleDeclarations> -> <moduleDeclaration> <moduleDeclarations> 
<moduleDeclarations> -> EPSILON
<moduleDeclaration> -> DECLARE MODULE ID SEMICOL
<otherModules> -> <module> <otherModules> 
<otherModules> -> EPSILON
<driverModule> -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>
<module> -> DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>
<ret> -> RETURNS SQBO <output_plist> SQBC SEMICOL 
<ret> -> EPSILON
<input_plist_lr> -> COMMA ID COLON <dataType> <input_plist_lr> 
<input_plist_lr> -> EPSILON
<input_plist> -> ID COLON <dataType> <input_plist_lr>
<output_plist_lr> -> COMMA ID COLON <type> <output_plist_lr> 
<output_plist_lr> -> EPSILON
<output_plist> -> ID COLON <type> <output_plist_lr>
<datatype> -> INTEGER 
<datatype> -> REAL 
<datatype> -> BOOLEAN 
<datatype> -> ARRAY SQBO <rangeArr> SQBC OF <type>
<rangeArr> -> <index> RANGEOP <index>
<type> -> INTEGER 
<type> -> REAL 
<type> -> BOOLEAN
<moduleDef> -> START <statements> END
<statements> -> <statement> <statements> 
<statements> -> EPSILON
<statement> -> <ioStmt> 
<statement> -> <simpleStmt> 
<statement> -> <declareStmt> 
<statement> -> <conditionalStmt> 
<statement> -> <iterativeStmt>
<ioStmt> -> GET_VALUE BO ID BC SEMICOL 
<ioStmt> -> PRINT BO <printOpt> BC SEMICOL
<var> -> ID <whichId> 
<var> -> NUM
<var> -> RNUM
<whichId> -> SQBO <index> SQBC 
<whichId> -> EPSILON
<printOpt> -> <booleanConst>
<printOpt> -> <var>
<simpleStmt> -> <assignmentStmt> 
<simpleStmt> -> <moduleReuseStmt>
<assignmentStmt> -> ID <whichStmt>
<whichStmt> -> <lvalueIDStmt> 
<whichStmt> -> <lvalueARRStmt>
<lvalueIDStmt> -> ASSIGNOP <expression> SEMICOL
<lvalueARRStmt> -> SQBO <index> SQBC ASSIGNOP <expression> SEMICOL
<index> -> NUM 
<index> -> ID
<moduleReuseStmt> -> <optional> USE MODULE ID WITH PARAMETERS <idList> SEMICOL
<optional> -> SQBO <idList> SQBC ASSIGNOP 
<optional> -> EPSILON
<idList_lr> -> COMMA ID <idList_lr> 
<idList_lr> -> EPSILON
<idList> -> ID <idList_lr> 
<expression> -> <opt_expr> <opt_expr_lr>
<opt_expr_lr> -> <logicalOp> <opt_expr> <opt_expr_lr>
<opt_expr_lr> -> EPSILON
<opt_expr> -> <arithmeticExpr> <one_more_opt>
<opt_expr> -> <booleanConst>
<one_more_opt> -> <relationalOp> <arithmeticExpr> <one_more_opt>
<one_more_opt> -> EPSILON
<booleanConst> -> true
<booleanConst> -> false
<arithmeticExpr_lr> -> <op1> <term> <arithmeticExpr_lr> 
<arithmeticExpr_lr> -> EPSILON
<arithmeticExpr> -> <term> <arithmeticExpr_lr>
<term_lr> -> <op2> <factor> <term_lr> 
<term_lr> -> EPSILON
<term> -> <factor> <term_lr>
<factor> -> BO <arithmeticExpr> BC 
<factor> -> <var>
<factor> -> <op1> <factor>
<op> -> PLUS 
<op> -> MINUS 
<op> -> MUL 
<op> -> DIV
<op1> -> PLUS 
<op1> -> MINUS
<op2> -> MUL 
<op2> -> DIV
<logicalOp> -> AND 
<logicalOp> -> OR
<relationalOp> -> LT 
<relationalOp> -> LE 
<relationalOp> -> GT 
<relationalOp> -> GE 
<relationalOp> -> EQ 
<relationalOp> -> NE
<declareStmt> -> DECLARE <idList> COLON <dataType> SEMICOL
<value> -> NUM 
<value> -> TRUE 
<value> -> FALSE
<caseStmt> -> CASE <value> COLON <statements> BREAK SEMICOL <caseStmt> 
<caseStmt> -> CASE <value> COLON <statements> BREAK SEMICOL
<default> -> DEFAULT COLON <statements> BREAK SEMICOL 
<default> -> EPSILON
<conditionalStmt> -> SWITCH BO ID BC START <caseStmt> <default> END
<range> -> NUM RANGEOP NUM
<iterativeStmt> -> FOR BO ID IN <range> BC START <statements> END 
<iterativeStmt> -> WHILE BO <expression> BC START <statements> END
