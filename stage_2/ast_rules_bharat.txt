Following are the attributes used:
a) syn - for synthesized attributes
b) inh - for inherited attributes
c) addr - to denote address of terminal nodes
d)  

****************************************************************************************************************
[1] program -> moduleDeclarations otherModules driverModule otherModules

[2] moduleDeclarations -> moduleDeclaration moduleDeclarations1 

    moduleDeclarations1.inh = moduleDeclaration.syn
    

[3] moduleDeclarations -> EPS

[4] moduleDeclaration -> DECLARE MODULE ID SEMICOL

    moduleDeclaration.syn = ID.addr
    freenodes(DECLARE, MODULE, SEMICOL)

[5] otherModules -> module otherModules 

[6] otherModules -> EPS

[7] driverModule -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF moduleDef

[8] module -> DEF MODULE ID ENDDEF TAKES INPUT SQBO input_plist SQBC SEMICOL ret moduleDef

[9] ret -> RETURNS SQBO output_plist SQBC SEMICOL 

[10] ret -> EPS

[11] input_plist_lr -> COMMA ID COLON datatype input_plist_lr 

[12] input_plist_lr -> EPS

[13] input_plist -> ID COLON datatype input_plist_lr

[14] output_plist_lr -> COMMA ID COLON type output_plist_lr 

[15] output_plist_lr -> EPS

[16] output_plist -> ID COLON type output_plist_lr

[17] datatype -> INTEGER

    datatype.syn = INTEGER.addr

[18] datatype -> REAL
    
    datatype.syn = REAL.addr

[19] datatype -> BOOLEAN

    datatype.syn = BOOLEAN.addr

[20] datatype -> ARRAY SQBO rangeArr SQBC OF type

[21] rangeArr -> index_nt RANGEOP index_nt

[22] type -> INTEGER

    type.syn = INTEGER.addr

[23] type -> REAL

    type.syn = REAL.addr

[24] type -> BOOLEAN

    type.syn = BOOLEAN.addr

[25] moduleDef -> START statements END

[26] statements -> statement statements 

[27] statements -> EPS

[28] statement -> ioStmt 

[29] statement -> simpleStmt 

[30] statement -> declareStmt 

[31] statement -> conditionalStmt 

[32] statement -> iterativeStmt

[33] ioStmt -> GET_VALUE BO ID BC SEMICOL 

[34] ioStmt -> PRINT BO printOpt BC SEMICOL

[35] var -> ID whichId 

[36] var -> NUM

    var.syn = NUM.addr

[37] var -> RNUM

    var.syn = RNUM.addr

[38] whichId -> SQBO index_nt SQBC 

[39] whichId -> EPS

[40] printOpt -> booleanConst

[41] printOpt -> var

[42] simpleStmt -> assignmentStmt 

[43] simpleStmt -> moduleReuseStmt

[44] assignmentStmt -> ID whichStmt

[45] whichStmt -> lvalueIDStmt 

[46] whichStmt -> lvalueARRStmt

[47] lvalueIDStmt -> ASSIGNOP expression SEMICOL

[48] lvalueARRStmt -> SQBO index_nt SQBC ASSIGNOP expression SEMICOL

[49] index_nt -> NUM 

    index_nt.syn = NUM.addr

[50] index_nt -> ID

    index_nt.syn = ID.addr

[51] moduleReuseStmt -> optional USE MODULE ID WITH PARAMETERS idList SEMICOL

[52] optional -> SQBO idList SQBC ASSIGNOP 

[53] optional -> EPS

[54] idList_lr -> COMMA ID idList_lr 

[55] idList_lr -> EPS

[56] idList -> ID idList_lr 

[57] expression -> unaryExpression

[58] expression -> arithmeticOrBooleanExpression

[59] unaryExpression -> MINUS unary_opt

[60] unaryExpression -> PLUS unary_opt

[61] unary_opt -> BO arithmeticExpr BC

[62] unary_opt -> var

[63] arithmeticOrBooleanExpression -> opt_expr opt_expr_lr

[64] opt_expr_lr -> logicalOp opt_expr opt_expr_lr

[65] opt_expr_lr -> EPS

[66] opt_expr -> arithmeticExpr one_more_opt

[67] opt_expr -> booleanConst

[68] one_more_opt -> relationalOp arithmeticExpr

[69] one_more_opt -> EPS

[70] booleanConst -> TRUE

    booleanConst.syn = TRUE

[71] booleanConst -> FALSE

    booleanConst.syn = FALSE

[72] arithmeticExpr_lr -> op1 term arithmeticExpr_lr 

[73] arithmeticExpr_lr -> EPS

[74] arithmeticExpr -> term arithmeticExpr_lr

[75] term_lr -> op2 factor term_lr 

[76] term_lr -> EPS

[77] term -> factor term_lr

[78] factor -> BO arithmeticOrBooleanExpression BC 

[79] factor -> var

[80] op1 -> PLUS
    
    op1.syn = PLUS.addr

[81] op1 -> MINUS

    op1.syn = MINUS.addr

[82] op2 -> MUL

    op2.syn = MUL.addr

[83] op2 -> DIV

    op2.syn = DIV.addr

[84] logicalOp -> AND

    logicalOp.syn = AND.addr

[85] logicalOp -> OR

    logicalOp.syn = OR.addr

[86] relationalOp -> LT

    logicalOp.syn = LT.addr

[87] relationalOp -> LE

    logicalOp.syn = LE.addr

[88] relationalOp -> GT

    logicalOp.syn = GT.addr

[89] relationalOp -> GE

    logicalOp.syn = GE.addr

[90] relationalOp -> EQ

    logicalOp.syn = EQ.addr

[91] relationalOp -> NE

    relationalOp = NE.addr

[92] declareStmt -> DECLARE idList COLON datatype SEMICOL

[93] value -> NUM

    value.syn = NUM.addr

[94] value -> TRUE

    value.syn = TRUE.addr

[95] value -> FALSE

    value.syn = FALSE.addr

[96] caseStmts -> CASE value COLON statements BREAK SEMICOL caseStmt

[97] caseStmt -> CASE value COLON statements BREAK SEMICOL caseStmt

[98] caseStmt -> EPS

[99] default_nt -> DEFAULT COLON statements BREAK SEMICOL 

[100] default_nt -> EPS

[101] conditionalStmt -> SWITCH BO ID BC START caseStmts default_nt END

[102] range -> NUM RANGEOP NUM

[103] iterativeStmt -> FOR BO ID IN range BC START statements END 

[104] iterativeStmt -> WHILE BO arithmeticOrBooleanExpression BC START statements END