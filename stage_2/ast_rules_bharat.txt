Following are the attributes used:
a) syn - for synthesized attributes
b) inh - for inherited attributes
c) addr - to denote address of terminal nodes
d)  

****************************************************************************************************************
[1] program -> moduleDeclarations otherModules driverModule otherModules

[2] moduleDeclarations -> moduleDeclaration moduleDeclarations1 

    Top-down: moduleDeclarations1.inh = insert_at_end(moduleDeclarations.inh, moduleDeclaration.syn)  //insert_at_end(head, node)
    Bottom-up: moduleDeclarations.syn = moduleDeclarations1.syn ; freenodes(moduleDeclarations1, moduleDeclaration)   

[3] moduleDeclarations -> EPS

    moduleDeclarations.syn = moduleDeclarations.inh

[4] moduleDeclaration -> DECLARE MODULE ID SEMICOL

    moduleDeclaration.syn = ID.addr
    freenodes(DECLARE, MODULE, SEMICOL)

[5] otherModules -> module otherModules 

[6] otherModules -> EPS

[7] driverModule -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF moduleDef

[8] module -> DEF MODULE ID ENDDEF TAKES INPUT SQBO input_plist SQBC SEMICOL ret moduleDef

    module.addr = make_node(ID.addr, input_plist.addr, ret.addr, moduleDef.addr)
    /* 
    make_node() will create an array of a fixed number of pointers.
    Here, addr attribute of module will point to this array of pointers.
    */
    freenodes(DEF, MODULE, ENDDEF, TAKES, INPUT, SQBO, SQBC, SEMICOL)

[9] ret -> RETURNS SQBO output_plist SQBC SEMICOL

    ret.addr = output_plist.addr
    freenodes(RETURNS, SQBO, SQBC, SEMICOL)

[10] ret -> EPS

    ret.addr = NULL

[11] input_plist_lr -> COMMA ID COLON datatype input_plist_lr



[12] input_plist_lr -> EPS

[13] input_plist -> ID COLON datatype input_plist_lr

[14] output_plist_lr -> COMMA ID COLON type output_plist_lr 

[15] output_plist_lr -> EPS

[16] output_plist -> ID COLON type output_plist_lr

[17] datatype -> INTEGER

    datatype.syn = INTEGER.addr

[18] datatype -> REAL
    
    datatype.syn = REAL.addr

[19] datatype -> BOOLEAN

    datatype.syn = BOOLEAN.addr

[20] datatype -> ARRAY SQBO rangeArr SQBC OF type

[21] rangeArr -> index_nt1 RANGEOP index_nt2

[22] type -> INTEGER

    type.addr = INTEGER.addr

[23] type -> REAL

    type.addr = REAL.addr

[24] type -> BOOLEAN

    type.addr = BOOLEAN.addr

[25] moduleDef -> START statements END

    moduleDef.addr = statements.addr
    freenodes(START, END)

[26] statements -> statement statements 

[27] statements -> EPS

[28] statement -> ioStmt

    statement.addr = iostmt.addr
    freenodes(iostmt)

[29] statement -> simpleStmt

    statement.addr = simpleStmt.addr
    freenodes(simpleStmt)

[30] statement -> declareStmt

    statement.addr = declareStmt.addr
    freenodes(declareStmt)

[31] statement -> conditionalStmt
    
    statement.addr = conditionalStmt.addr
    freenodes(conditionalStmt)

[32] statement -> iterativeStmt

    statement.addr = iterativeStmt.addr
    freenodes(iterativeStmt)

[33] ioStmt -> GET_VALUE BO ID BC SEMICOL

    iostmt.addr = ID.addr
    freenodes(GET_VALUE, BO, BC, SEMICOL)

[34] ioStmt -> PRINT BO printOpt BC SEMICOL

    iostmt.addr = printOpt.addr
    freenodes(PRINT, BO, BC, SEMICOL)

[35] var -> ID whichId

    var.addr = make_node(ID.addr, whichId.addr)
    freenodes(whichId)

[36] var -> NUM

    var.addr = NUM.addr // This rule is actually involving creation of a new AST node and removal of the parse tree node

[37] var -> RNUM

    var.addr = RNUM.addr

[38] whichId -> SQBO index_nt SQBC

    whichId.addr = index_nt.addr
    freenodes(SQBO, index_nt, SQBC)

[39] whichId -> EPS

    whichId.addr = NULL;

[40] printOpt -> booleanConst

    printOpt.addr = booleanConst.addr
    freenodes(booleanConst)

[41] printOpt -> var

    printOpt.addr = var.addr
    freenodes(var)

[42] simpleStmt -> assignmentStmt

    simpleStmt.addr = assignmentStmt.addr
    freenodes(assignmentStmt)

[43] simpleStmt -> moduleReuseStmt

    simpleStmt.addr = moduleReuseStmt.addr
    freenodes(moduleReuseStmt)

[44] assignmentStmt -> ID whichStmt

    assignmentStmt.addr = make_node(ID.addr, whichStmt.addr)
    freenodes(whichStmt)

[45] whichStmt -> lvalueIDStmt

    whichStmt.addr = lvalueIDStmt.addr
    freenodes(lvalueIDStmt)

[46] whichStmt -> lvalueARRStmt

    whichStmt.addr = lvalueARRStmt.addr
    freenodes(lvalueARRStmt)

[47] lvalueIDStmt -> ASSIGNOP expression SEMICOL

    lvalueIDStmt.addr = expression.addr
    freenodes(ASSIGNOP, expression, SEMICOL)

[48] lvalueARRStmt -> SQBO index_nt SQBC ASSIGNOP expression SEMICOL

    lvalueARRStmt.addr = make_node(index_nt.addr, expression.addr)
    freenodes(SQBO, index_nt, SQBC, ASSIGNOP, expression, SEMICOL)

[49] index_nt -> NUM 

    index_nt.addr = NUM.addr

[50] index_nt -> ID

    index_nt.addr = ID.addr

[51] moduleReuseStmt -> optional USE MODULE ID WITH PARAMETERS idList SEMICOL

    moduleReuseStmt.addr = make_node(optional.addr, ID.addr, idList.addr)
    freenodes(optional, USE, MODULE, WITH, PARAMETERS, idList, SEMICOL)

[52] optional -> SQBO idList SQBC ASSIGNOP

    optional.addr = idList.addr //to be implemented as make_node(idList.addr) while coding - a mere suggestion, though
    freenodes(SQBO, idList, SQBC, ASSIGNOP)

[53] optional -> EPS

    optional.addr = NULL

[54] idList_lr -> COMMA ID idList_lr1

    idList_lr.addr = make_node(ID.addr, idList_lr1.addr)
    freenodes(COMMA, idList_lr1)

[55] idList_lr -> EPS

    idList_lr.addr = NULL

[56] idList -> ID idList_lr

    idList.addr = make_node(ID.addr, idList_lr.addr)
    freenodes(idList_lr)

[57] expression -> unaryExpression

    expression.addr = unaryExpression.addr
    freenodes(unaryExpression)

[58] expression -> arithmeticOrBooleanExpression

    expression.addr = arithmeticOrBooleanExpression.addr
    freenodes(arithmeticOrBooleanExpression)

[59] unaryExpression -> MINUS unary_opt

[60] unaryExpression -> PLUS unary_opt

[61] unary_opt -> BO arithmeticExpr BC

[62] unary_opt -> var

[63] arithmeticOrBooleanExpression -> opt_expr opt_expr_lr

[64] opt_expr_lr -> logicalOp opt_expr opt_expr_lr

[65] opt_expr_lr -> EPS

[66] opt_expr -> arithmeticExpr one_more_opt

[67] opt_expr -> booleanConst

[68] one_more_opt -> relationalOp arithmeticExpr

[69] one_more_opt -> EPS

[70] booleanConst -> TRUE

    booleanConst.addr = TRUE

[71] booleanConst -> FALSE

    booleanConst.addr = FALSE

[72] arithmeticExpr_lr -> op1 term arithmeticExpr_lr 

[73] arithmeticExpr_lr -> EPS

[74] arithmeticExpr -> term arithmeticExpr_lr

[75] term_lr -> op2 factor term_lr 

[76] term_lr -> EPS

[77] term -> factor term_lr

[78] factor -> BO arithmeticOrBooleanExpression BC 

[79] factor -> var

[80] op1 -> PLUS
    
    op1.addr = PLUS.addr

[81] op1 -> MINUS

    op1.addr = MINUS.addr

[82] op2 -> MUL

    op2.addr = MUL.addr

[83] op2 -> DIV

    op2.addr = DIV.addr

[84] logicalOp -> AND

    logicalOp.addr = AND.addr

[85] logicalOp -> OR

    logicalOp.addr = OR.addr

[86] relationalOp -> LT

    relationalOp.addr = LT.addr

[87] relationalOp -> LE

    relationalOp.addr = LE.addr

[88] relationalOp -> GT

     relationalOp.addr = GT.addr

[89] relationalOp -> GE

    relationalOp.addr = GE.addr

[90] relationalOp -> EQ

    relationalOp.addr = EQ.addr

[91] relationalOp -> NE

    relationalOp.addr = NE.addr

[92] declareStmt -> DECLARE idList COLON datatype SEMICOL

[93] value -> NUM

    value.addr = NUM.addr

[94] value -> TRUE

    value.addr = TRUE.addr

[95] value -> FALSE

    value.addr = FALSE.addr

[96] caseStmts -> CASE value COLON statements BREAK SEMICOL caseStmt

[97] caseStmt -> CASE value COLON statements BREAK SEMICOL caseStmt

[98] caseStmt -> EPS

[99] default_nt -> DEFAULT COLON statements BREAK SEMICOL 

[100] default_nt -> EPS

[101] conditionalStmt -> SWITCH BO ID BC START caseStmts default_nt END

[102] range -> NUM1 RANGEOP NUM2

    range.addr = make_node(NUM1.addr, NUM2.addr)
    freenodes(RANGEOP)

[103] iterativeStmt -> FOR BO ID IN range BC START statements END 

[104] iterativeStmt -> WHILE BO arithmeticOrBooleanExpression BC START statements END